<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="/favicon.png" />
    <link
      href="https://api.fontshare.com/v2/css?f[]=satoshi@700,900,400&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/src/style.css" />
    <title>Games | Jones Jankovic</title>
  </head>
  <body>
    <header-component class="main-header" id="navbar">
      <div class="nav-container">
        <div class="nav-left">
          <a href="/" class="nav-name-link">
            <span class="nav-name">Jones Jankovic</span>
          </a>
          <div class="glass-nav">
            <a href="/" class="glass-btn">Home</a>
            <a href="/games/" class="glass-btn">Games</a>
          </div>
        </div>

        <div class="nav-right">
          <a
            href="https://discord.com/users/1378992101970280471"
            target="_blank"
            class="nav-icon discord-icon"
          >
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path
                d="M18.59 5.88997C17.36 5.31997 16.05 4.89997 14.67 4.65997C14.5 4.95997 14.3 5.36997 14.17 5.69997C12.71 5.47997 11.26 5.47997 9.83001 5.69997C9.69001 5.36997 9.49001 4.95997 9.32001 4.65997C7.94001 4.89997 6.63001 5.31997 5.40001 5.88997C2.92001 9.62997 2.25001 13.28 2.58001 16.87C4.23001 18.1 5.82001 18.84 7.39001 19.33C7.78001 18.8 8.12001 18.23 8.42001 17.64C7.85001 17.43 7.31001 17.16 6.80001 16.85C6.94001 16.75 7.07001 16.64 7.20001 16.54C10.33 18 13.72 18 16.81 16.54C16.94 16.65 17.07 16.75 17.21 16.85C16.7 17.16 16.15 17.42 15.59 17.64C15.89 18.23 16.23 18.8 16.62 19.33C18.19 18.84 19.79 18.1 21.43 16.87C21.82 12.7 20.76 9.08997 18.61 5.88997H18.59ZM8.84001 14.67C7.90001 14.67 7.13001 13.8 7.13001 12.73C7.13001 11.66 7.88001 10.79 8.84001 10.79C9.80001 10.79 10.56 11.66 10.55 12.73C10.55 13.79 9.80001 14.67 8.84001 14.67ZM15.15 14.67C14.21 14.67 13.44 13.8 13.44 12.73C13.44 11.66 14.19 10.79 15.15 10.79C16.11 10.79 16.87 11.66 16.86 12.73C16.86 13.79 16.11 14.67 15.15 14.67Z"
                fill="white"
              ></path>
            </svg>
          </a>

          <a
            href="https://github.com/Jones8683"
            target="_blank"
            class="nav-icon github-icon"
          >
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path
                d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.041-1.416-4.041-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"
                fill="white"
              ></path>
            </svg>
          </a>
        </div>
      </div>
    </header-component>

    <main
      style="
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        min-height: 100vh;
        padding-top: 5vh;
        text-align: center;
      "
    >
      <style>
        /* Local Styles */
        .game-wrapper {
          display: flex;
          gap: 20px;
          align-items: flex-start;
          justify-content: center;
          margin-top: 20px;
        }

        .canvas-container {
          position: relative;
          padding: 10px; /* Thicker frame */
          background: #1a1a1a;
          border: 1px solid rgba(255, 255, 255, 0.1);
          border-radius: 12px;
          box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        canvas {
          display: block;
          background-color: #0d0d0d; /* Darker matte background */
          border-radius: 4px;
        }

        .sidebar {
          display: flex;
          flex-direction: column;
          gap: 15px;
          width: 100px;
        }

        .info-box {
          background: rgba(255, 255, 255, 0.05);
          border: 1px solid rgba(255, 255, 255, 0.1);
          border-radius: 8px;
          padding: 10px;
          text-align: center;
        }

        .label {
          font-size: 10px;
          color: #94a3b8;
          text-transform: uppercase;
          letter-spacing: 1px;
          margin-bottom: 4px;
        }

        .value {
          font-size: 18px;
          font-weight: 800;
          color: white;
        }

        .controls-guide {
          margin-top: 20px;
          font-size: 12px;
          color: #64748b;
          line-height: 1.6;
          text-align: center;
        }

        .key {
          color: #fff;
          font-weight: 700;
        }
      </style>

      <h1
        class="name-title"
        style="
          font-size: 64px;
          margin: 0;
          letter-spacing: -2px;
          font-weight: 900;
          color: white;
        "
      >
        Tetris
      </h1>

      <div class="game-wrapper">
        <div class="sidebar">
          <div class="info-box">
            <div class="label">Hold</div>
            <canvas id="holdCanvas" width="80" height="80"></canvas>
          </div>
          <div class="info-box">
            <div class="label">Score</div>
            <div class="value" id="scoreDiv">0</div>
          </div>
        </div>

        <div class="canvas-container">
          <canvas id="gameCanvas" width="240" height="400"></canvas>

          <div
            id="gameOverMsg"
            style="
              display: none;
              position: absolute;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background: rgba(0, 0, 0, 0.85);
              flex-direction: column;
              align-items: center;
              justify-content: center;
              z-index: 10;
              border-radius: 8px;
            "
          >
            <h2 style="font-size: 24px; color: white; margin: 0 0 10px 0">
              GAME OVER
            </h2>
            <button
              onclick="resetGame()"
              style="
                background: white;
                color: black;
                border: none;
                padding: 8px 16px;
                font-weight: bold;
                cursor: pointer;
                border-radius: 4px;
              "
            >
              RETRY
            </button>
          </div>
        </div>

        <div class="sidebar">
          <div class="info-box">
            <div class="label">Next</div>
            <canvas id="nextCanvas" width="80" height="80"></canvas>
          </div>
          <div class="info-box">
            <div class="label">Level</div>
            <div class="value" id="levelDiv">1</div>
          </div>
        </div>
      </div>

      <div class="controls-guide">
        <span class="key">ARROWS</span> to Move & Rotate<br />
        <span class="key">SPACE</span> to Hard Drop<br />
        <span class="key">C</span> to Hold
      </div>

      <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const nextCtx = document.getElementById("nextCanvas").getContext("2d");
        const holdCtx = document.getElementById("holdCanvas").getContext("2d");

        ctx.scale(20, 20);
        nextCtx.scale(20, 20);
        holdCtx.scale(20, 20);

        // "Chocolate" Colors (Slightly more pastel/matte, less neon)
        const colors = [
          null,
          "#FF0D72", // T
          "#0DC2FF", // I
          "#0DFF72", // S
          "#F538FF", // Z
          "#FF8E0D", // L
          "#FFE138", // J
          "#3877FF", // O
        ];

        const arena = createMatrix(12, 20);

        const player = {
          pos: { x: 0, y: 0 },
          matrix: null,
          score: 0,
          level: 1,
          lines: 0,
          next: null,
          hold: null,
          canHold: true,
        };

        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let isGameOver = false;

        // Animation States
        let hardDropEffect = {
          active: false,
          x: 0,
          y: 0,
          w: 0,
          h: 0,
          alpha: 0,
        };
        let rotateFlash = 0; // Timer for flash effect on piece

        function createMatrix(w, h) {
          const matrix = [];
          while (h--) matrix.push(new Array(w).fill(0));
          return matrix;
        }

        function createPiece(type) {
          if (type === "I")
            return [
              [0, 1, 0, 0],
              [0, 1, 0, 0],
              [0, 1, 0, 0],
              [0, 1, 0, 0],
            ];
          if (type === "L")
            return [
              [0, 2, 0],
              [0, 2, 0],
              [0, 2, 2],
            ];
          if (type === "J")
            return [
              [0, 3, 0],
              [0, 3, 0],
              [3, 3, 0],
            ];
          if (type === "O")
            return [
              [4, 4],
              [4, 4],
            ];
          if (type === "Z")
            return [
              [5, 5, 0],
              [0, 5, 5],
              [0, 0, 0],
            ];
          if (type === "S")
            return [
              [0, 6, 6],
              [6, 6, 0],
              [0, 0, 0],
            ];
          if (type === "T")
            return [
              [0, 7, 0],
              [7, 7, 7],
              [0, 0, 0],
            ];
        }

        let piecesBag = [];
        function getNextPiece() {
          if (piecesBag.length === 0) {
            piecesBag = ["I", "L", "J", "O", "Z", "S", "T"];
            for (let i = piecesBag.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [piecesBag[i], piecesBag[j]] = [piecesBag[j], piecesBag[i]];
            }
          }
          return createPiece(piecesBag.pop());
        }

        function draw() {
          // 1. Draw Background
          ctx.fillStyle = "#0d0d0d";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // 2. Draw Hard Drop Animation Trail
          if (hardDropEffect.active && hardDropEffect.alpha > 0) {
            ctx.fillStyle = `rgba(255, 255, 255, ${hardDropEffect.alpha})`;
            ctx.fillRect(
              hardDropEffect.x,
              hardDropEffect.y,
              hardDropEffect.w,
              hardDropEffect.h,
            );
            hardDropEffect.alpha -= 0.08; // Fade out speed
            if (hardDropEffect.alpha <= 0) hardDropEffect.active = false;
          }

          // 3. Draw Board
          drawMatrix(arena, { x: 0, y: 0 }, ctx);

          // 4. Draw Ghost Piece (Dimmed)
          const ghostPos = { ...player.pos };
          while (!collide(arena, { pos: ghostPos, matrix: player.matrix })) {
            ghostPos.y++;
          }
          ghostPos.y--;

          // Draw Ghost as just outlines or very dim blocks
          drawMatrix(player.matrix, ghostPos, ctx, true);

          // 5. Draw Active Piece
          drawMatrix(player.matrix, player.pos, ctx, false, rotateFlash > 0);

          // Reduce rotation flash timer
          if (rotateFlash > 0) rotateFlash--;
        }

        // THE "CHOCOLATE BLOCK" RENDERER
        function drawMatrix(
          matrix,
          offset,
          context,
          isGhost = false,
          isFlash = false,
        ) {
          matrix.forEach((row, y) => {
            row.forEach((value, x) => {
              if (value !== 0) {
                const bx = x + offset.x;
                const by = y + offset.y;

                if (isGhost) {
                  // Simple outline for ghost
                  context.fillStyle = "rgba(255, 255, 255, 0.1)";
                  context.fillRect(bx, by, 1, 1);
                  return;
                }

                const baseColor = isFlash ? "#FFFFFF" : colors[value];

                // 1. Base Block
                context.fillStyle = baseColor;
                context.fillRect(bx, by, 1, 1);

                if (!isFlash) {
                  // 2. Top/Left Highlight (Bevel Light)
                  context.fillStyle = "rgba(255, 255, 255, 0.4)";
                  context.fillRect(bx, by, 1, 0.15); // Top strip
                  context.fillRect(bx, by, 0.15, 1); // Left strip

                  // 3. Bottom/Right Shadow (Bevel Dark)
                  context.fillStyle = "rgba(0, 0, 0, 0.4)";
                  context.fillRect(bx, by + 0.85, 1, 0.15); // Bottom strip
                  context.fillRect(bx + 0.85, by, 0.15, 1); // Right strip

                  // 4. Inner Dimple (Optional, makes it look indented)
                  context.fillStyle = "rgba(0, 0, 0, 0.1)";
                  context.fillRect(bx + 0.2, by + 0.2, 0.6, 0.6);
                }
              }
            });
          });
        }

        function drawPreview(ctx, matrix) {
          ctx.clearRect(0, 0, 400, 400);
          if (!matrix) return;
          const offsetX = (4 - matrix[0].length) / 2;
          const offsetY = (4 - matrix.length) / 2;
          // Use same chocolate renderer
          drawMatrix(matrix, { x: offsetX, y: offsetY }, ctx);
        }

        function collide(arena, player) {
          const m = player.matrix;
          const o = player.pos;
          for (let y = 0; y < m.length; ++y) {
            for (let x = 0; x < m[y].length; ++x) {
              if (
                m[y][x] !== 0 &&
                (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0
              ) {
                return true;
              }
            }
          }
          return false;
        }

        function arenaSweep() {
          let rowCount = 1;
          outer: for (let y = arena.length - 1; y > 0; --y) {
            for (let x = 0; x < arena[y].length; ++x) {
              if (arena[y][x] === 0) continue outer;
            }
            const row = arena.splice(y, 1)[0].fill(0);
            arena.unshift(row);
            ++y;
            player.score += rowCount * 100;
            player.lines++;
            rowCount *= 2;
          }
          updateScore();
        }

        function merge(arena, player) {
          player.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
              if (value !== 0)
                arena[y + player.pos.y][x + player.pos.x] = value;
            });
          });
        }

        function playerDrop() {
          player.pos.y++;
          if (collide(arena, player)) {
            player.pos.y--;
            merge(arena, player);
            playerReset();
            arenaSweep();
            updateScore();
            player.canHold = true;
          }
          dropCounter = 0;
        }

        function playerHardDrop() {
          const startY = player.pos.y;
          while (!collide(arena, player)) {
            player.pos.y++;
          }
          player.pos.y--;

          // Trigger Drop Animation (Beam)
          hardDropEffect = {
            active: true,
            x: player.pos.x,
            y: startY,
            w: player.matrix[0].length, // Approximation of width
            h: player.pos.y - startY + player.matrix.length,
            alpha: 0.4,
          };

          merge(arena, player);
          playerReset();
          arenaSweep();
          updateScore();
          player.canHold = true;
          dropCounter = 0;
        }

        function playerMove(dir) {
          player.pos.x += dir;
          if (collide(arena, player)) player.pos.x -= dir;
        }

        function playerReset() {
          if (player.next === null) player.next = getNextPiece();
          player.matrix = player.next;
          player.next = getNextPiece();
          drawPreview(nextCtx, player.next);
          player.pos.y = 0;
          player.pos.x =
            ((arena[0].length / 2) | 0) - ((player.matrix[0].length / 2) | 0);
          if (collide(arena, player)) {
            isGameOver = true;
            document.getElementById("gameOverMsg").style.display = "flex";
          }
        }

        function playerRotate(dir) {
          const pos = player.pos.x;
          let offset = 1;
          rotate(player.matrix, dir);
          while (collide(arena, player)) {
            player.pos.x += offset;
            offset = -(offset + (offset > 0 ? 1 : -1));
            if (offset > player.matrix[0].length) {
              rotate(player.matrix, -dir);
              player.pos.x = pos;
              return;
            }
          }
          // Trigger Rotate Animation (Flash)
          rotateFlash = 5; // Flash for 5 frames
        }

        function rotate(matrix, dir) {
          for (let y = 0; y < matrix.length; ++y) {
            for (let x = 0; x < y; ++x) {
              [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
            }
          }
          if (dir > 0) matrix.forEach((row) => row.reverse());
          else matrix.reverse();
        }

        function playerHold() {
          if (!player.canHold) return;
          if (player.hold === null) {
            player.hold = player.matrix;
            player.matrix = player.next;
            player.next = getNextPiece();
            drawPreview(nextCtx, player.next);
          } else {
            const temp = player.matrix;
            player.matrix = player.hold;
            player.hold = temp;
          }
          drawPreview(holdCtx, player.hold);
          player.pos.y = 0;
          player.pos.x =
            ((arena[0].length / 2) | 0) - ((player.matrix[0].length / 2) | 0);
          player.canHold = false;
        }

        function update(time = 0) {
          if (isGameOver) return;
          const deltaTime = time - lastTime;
          lastTime = time;
          dropCounter += deltaTime;
          if (dropCounter > dropInterval) playerDrop();
          draw();
          requestAnimationFrame(update);
        }

        function updateScore() {
          document.getElementById("scoreDiv").innerText = player.score;
          player.level = Math.floor(player.lines / 10) + 1;
          document.getElementById("levelDiv").innerText = player.level;
          dropInterval = Math.max(100, 1000 - (player.level - 1) * 100);
        }

        function resetGame() {
          arena.forEach((row) => row.fill(0));
          player.score = 0;
          player.lines = 0;
          player.level = 1;
          player.hold = null;
          player.next = null;
          drawPreview(holdCtx, null);
          updateScore();
          isGameOver = false;
          document.getElementById("gameOverMsg").style.display = "none";
          playerReset();
          update();
        }

        document.addEventListener("keydown", (event) => {
          if (isGameOver) return;
          if (event.keyCode === 37) playerMove(-1);
          else if (event.keyCode === 39) playerMove(1);
          else if (event.keyCode === 40) playerDrop();
          else if (event.keyCode === 38) playerRotate(1);
          else if (event.keyCode === 32) playerHardDrop();
          else if (event.keyCode === 67) playerHold();
        });

        window.addEventListener(
          "keydown",
          function (e) {
            if (
              [
                "Space",
                "ArrowUp",
                "ArrowDown",
                "ArrowLeft",
                "ArrowRight",
              ].indexOf(e.code) > -1
            ) {
              e.preventDefault();
            }
          },
          false,
        );

        playerReset();
        updateScore();
        update();
      </script>
    </main>

    <footer class="main-footer">
      <div class="footer-line"></div>
      <p>&copy; 2026 Jones Jankovic</p>
    </footer>
    <script src="/src/main.js" type="module"></script>
  </body>
</html>
